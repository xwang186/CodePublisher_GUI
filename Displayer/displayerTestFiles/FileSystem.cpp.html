<!Doctype html>
<html>
  <head>
    <style>
      body {
        padding:15px 40px;
        font-family: Consolas;
        font-size: 1.25em;
        font-weight: normal;
      }
    </style>
  </head>
  <body><h3>FileSystem.cpp</h3><pre>/////////////////////////////////////////////////////////////////////////////<br>// FileSystem.cpp - Support file and directory operations                  //<br>// ver 2.8                                                                 //<br>// ----------------------------------------------------------------------- //<br>// copyright ?Jim Fawcett, 2012                                           //<br>// All rights granted provided that this notice is retained                //<br>// ----------------------------------------------------------------------- //<br>// Language:    Visual C++, Visual Studio 2010                             //<br>// Platform:    Dell XPS 8300, Core i7, Windows 7 SP1                      //<br>// Application: Summer Projects, 2012                                      //<br>// Author:      Jim Fawcett, CST 4-187, Syracuse University                //<br>//              (315) 443-3948, jfawcett@twcny.rr.com                      //<br>/////////////////////////////////////////////////////////////////////////////<br><br>#include &ltiostream&gt<br>#include &ltstring&gt<br>#include &ltsstream&gt<br>#include &ltiomanip&gt<br>#include &ltutility&gt<br>#include &ltclocale&gt<br>#include &ltlocale&gt<br>#include "FileSystem.h"<br><br>using namespace FileSystem;<br><br>/////////////////////////////////////////////////////////<br>// helper FileSystemSearch<br><br>class FileSystemSearch<br>{<br>public:<br>  FileSystemSearch();<br>  ~FileSystemSearch();<br>  std::string firstFile(const std::string& path=".", const std::string& pattern="*.*");<br>  std::string nextFile();<br>  std::string firstDirectory(const std::string& path=".", const std::string& pattern="*.*");<br>  std::string nextDirectory();<br>  void close();<br>private:<br>  HANDLE hFindFile;<br>  WIN32_FIND_DATAA FindFileData;<br>  WIN32_FIND_DATAA* pFindFileData;<br>};<br><br>FileSystemSearch::FileSystemSearch() { pFindFileData = &FindFileData; }<br>FileSystemSearch::~FileSystemSearch() { ::FindClose(hFindFile); }<br>void FileSystemSearch::close() { ::FindClose(hFindFile); }<br><br>//----&lt block constructor taking array iterators &gt-------------------------<br><br>Block::Block(Byte* beg, Byte* end) : bytes_(beg, end) {}<br><br>//----&lt push back block byte &gt---------------------------------------------<br><br>void Block::push_back(Byte b)<br>{<br>  bytes_.push_back(b);<br>}<br>//----&lt non-const indexer &gt------------------------------------------------<br><br>Byte& Block::operator[](size_t i)<br>{<br>  if(i&lt0 || bytes_.size() &lt= i)<br>    throw std::runtime_error("index out of range in Block");<br>  return bytes_[i];<br>}<br>//----&lt const indexer &gt----------------------------------------------------<br><br>Byte Block::operator[](size_t i) const<br>{<br>  if(i&lt0 || bytes_.size() &lt= i)<br>    throw std::runtime_error("index out of range in Block");<br>  return bytes_[i];<br>}<br>//----&lt equality comparison &gt----------------------------------------------<br><br>bool Block::operator==(const Block& block) const<br>{<br>  return bytes_ == block.bytes_;<br>}<br>//----&lt inequality comparison &gt--------------------------------------------<br><br>bool Block::operator!=(const Block& block) const<br>{<br>  return bytes_ != block.bytes_;<br>}<br>//----&lt return number of bytes in block &gt----------------------------------<br><br>size_t Block::size() const<br>{<br>  return bytes_.size();<br>}<br><br>//----&lt File constructor opens file stream &gt-------------------------------<br><br>File::File(const std::string& filespec) <br>    : name_(filespec), pIStream(nullptr), pOStream(nullptr), dirn_(in), typ_(text), good_(true)<br>{<br>}<br>//----&lt File destructor closes file stream &gt-------------------------------<br><br>File::~File() <br>{ <br>  if(pIStream)<br>  {<br>    pIStream-&gtclose(); <br>    delete pIStream;<br>    pIStream = nullptr;<br>    good_ = false;<br>  }<br>  if(pOStream)<br>  {<br>    pOStream-&gtclose();<br>    delete pOStream; <br>    pOStream = nullptr;<br>    good_ = false;<br>  }<br>}<br>//----&lt open for reading or writing &gt--------------------------------------<br><br>bool File::open(direction dirn, type typ)<br>{<br>  dirn_ = dirn;<br>  typ_ = typ;<br>  good_ = true;<br>  if(dirn == in)<br>  {<br>    pIStream = new std::ifstream;<br>    if(typ == binary)<br>      pIStream-&gtopen(name_.c_str(), std::ios::in | std::ios::binary);<br>    else<br>      pIStream-&gtopen(name_.c_str(), std::ios::in);<br>    if (!(*pIStream).good())<br>    {<br>      good_ = false;<br>      pIStream = nullptr;<br>      //throw std::runtime_error("\n  open for input failed in File constructor");<br>    }<br>  }<br>  else<br>  {<br>    pOStream = new std::ofstream;<br>    if(typ == binary)<br>      pOStream-&gtopen(name_.c_str(), std::ios::out | std::ios::binary);<br>    else<br>      pOStream-&gtopen(name_.c_str(), std::ios::out);<br>    if (!(*pOStream).good())<br>    {<br>      good_ = false;<br>      pOStream = nullptr;<br>      //throw std::runtime_error("\n  open for output failed in File constructor");<br>    }<br>  }<br>  return good_;<br>}<br>//----&lt reads one line of a text file &gt------------------------------------<br><br>std::string File::getLine(bool keepNewLines)<br>{<br>  if(pIStream == nullptr || !pIStream-&gtgood())<br>    throw std::runtime_error("input stream not open");<br>  if(typ_ == binary)<br>    throw std::runtime_error("getting text line from binary file");<br>  if(dirn_ == out)<br>    throw std::runtime_error("reading output file");<br><br>  std::string store;<br>  while (true)<br>  {<br>    char ch = pIStream-&gtget();<br>    if (!isGood())<br>      return store;<br>    if (ch == '\n')<br>    {<br>      if (keepNewLines)<br>        store += ch;<br>      return store;<br>    }<br>    store += ch;<br>  }<br>}<br>//----&lt read all lines of text file into one string &gt----------------------<br><br>std::string File::readAll(bool keepNewLines)<br>{<br>  std::string store;<br>  while (true)<br>  {<br>    if (!isGood())<br>      return store;<br>    store += getLine(keepNewLines);<br>    std::locale loc;<br>    if (store.size() &gt 0 && !std::isspace(store[store.size() - 1], loc))<br>      store += ' ';<br>  }<br>  return store;<br>}<br>//----&lt writes one line of a text to a file &gt------------------------------<br><br>void File::putLine(const std::string& s, bool wantReturn)<br>{<br>  if(pOStream == nullptr || !pOStream-&gtgood())<br>    throw std::runtime_error("output stream not open");<br>  if(typ_ == binary)<br>    throw std::runtime_error("writing text line to binary file");<br>  if(dirn_ == in)<br>    throw std::runtime_error("writing input file");<br>  for(size_t i=0; i&lts.size(); ++i)<br>    pOStream-&gtput(s[i]);<br>  if(wantReturn)<br>    pOStream-&gtput('\n');<br>  pOStream-&gtflush();<br>}<br>//----&lt reads a block of bytes from binary file &gt--------------------------<br><br>Block File::getBlock(size_t size)<br>{<br>  if(pIStream == nullptr || !pIStream-&gtgood())<br>    throw std::runtime_error("input stream not open");<br>  if(typ_ != binary)<br>    throw std::runtime_error("reading binary from text file");<br>  if(dirn_ == out)<br>    throw std::runtime_error("reading output file");<br>  Block blk;<br>  if(pIStream)<br>  {<br>    for(size_t i=0; i&ltsize; ++i)<br>    {<br>      Byte b;<br>      pIStream-&gtget(b);<br>      if(pIStream-&gtgood())<br>        blk.push_back(b);<br>      else<br>        break;<br>    }<br>  }<br>  return blk;<br>}<br>//----&lt writes a block of bytes to binary file &gt---------------------------<br><br>void File::putBlock(const Block& blk)<br>{<br>  if(pOStream == nullptr || !pOStream-&gtgood())<br>    throw std::runtime_error("output stream not open");<br>  if(typ_ != binary)<br>    throw std::runtime_error("writing binary to text file");<br>  if(dirn_ == in)<br>    throw std::runtime_error("writing input file");<br>  if(!pOStream-&gtgood())<br>    return;<br>  for(size_t i=0; i&ltblk.size(); ++i)<br>  {<br>    pOStream-&gtput(blk[i]);<br>  }<br>}<br>//----&lt read buffer of bytes from binary file &gt----------------------------<br><br>size_t File::getBuffer(size_t bufLen, File::byte* buffer)<br>{<br>  if (pIStream == nullptr || !pIStream-&gtgood())<br>    throw std::runtime_error("input stream not open");<br>  if (typ_ != binary)<br>    throw std::runtime_error("reading binary from text file");<br>  if (dirn_ == out)<br>    throw std::runtime_error("reading output file");<br>  size_t count = 0;<br>  while (pIStream-&gtgood())<br>  {<br>    buffer[count++] = pIStream-&gtget();<br>      if (count == bufLen)<br>        break;<br>  }<br>  if (!pIStream-&gtgood())  // don't write EOF char<br>    --count;<br>  return count;<br>}<br>//----&lt write buffer of bytes to binary file &gt-------------------------------<br><br>void File::putBuffer(size_t bufLen, File::byte* buffer)<br>{<br>  if (pOStream == nullptr || !pOStream-&gtgood())<br>    throw std::runtime_error("output stream not open");<br>  if (typ_ != binary)<br>    throw std::runtime_error("writing binary to text file");<br>  if (dirn_ == in)<br>    throw std::runtime_error("writing input file");<br>  if (!pOStream-&gtgood())<br>    return;<br>  size_t count = 0;<br>  while(pOStream-&gtgood())<br>  {<br>    pOStream-&gtput(buffer[count++]);<br>    if (count == bufLen)<br>      break;<br>  }<br>}<br>//----&lt tests for error free stream state &gt--------------------------------<br><br>bool File::isGood()<br>{<br>  if(!good_)<br>    return false;<br>  if(pIStream != nullptr)<br>    return (good_ = pIStream-&gtgood());<br>  if(pOStream != nullptr)<br>    return (good_ = pOStream-&gtgood());<br>  good_ = false;<br>  return good_;<br>}<br>//----&lt flushes output stream to its file &gt--------------------------------<br><br>void File::flush()<br>{<br>  if(pOStream != nullptr && pOStream-&gtgood())<br>    pOStream-&gtflush();<br>}<br>//----&lt clears error state enabling operations again &gt---------------------<br><br>void File::clear()<br>{<br>  if(pIStream != nullptr)<br>    pIStream-&gtclear();<br>  if(pOStream != nullptr)<br>    pOStream-&gtclear();<br>}<br>//----&lt close file handle &gt------------------------------------------------<br><br>void File::close()<br>{<br>  File::flush();<br>  if (pIStream != nullptr)<br>  {<br>    pIStream-&gtclose();<br>    pIStream = nullptr;<br>    good_ = false;<br>  }<br>  if (pOStream)<br>  {<br>    pOStream-&gtclose();<br>    pOStream = nullptr;<br>    good_ = false;<br>  }<br>}<br>//----&lt file exists &gt--------------------------------------------------<br><br>bool File::exists(const std::string& file)<br>{<br>  return ::GetFileAttributesA(file.c_str()) != INVALID_FILE_ATTRIBUTES;<br>}<br>//----&lt copy file &gt----------------------------------------------------<br><br>bool File::copy(const std::string& src, const std::string& dst, bool failIfExists)<br>{<br>  return ::CopyFileA(src.c_str(), dst.c_str(), failIfExists) != 0;<br>}<br>//----&lt remove file &gt--------------------------------------------------<br><br>bool File::remove(const std::string& file)<br>{<br>  return ::DeleteFileA(file.c_str()) != 0;<br>}<br>//----&lt constructor &gt--------------------------------------------------<br><br>FileInfo::FileInfo(const std::string& fileSpec)<br>{<br>  hFindFile = ::FindFirstFileA(fileSpec.c_str(), &data);<br>  if(hFindFile == INVALID_HANDLE_VALUE)<br>    good_ = false;<br>  else<br>    good_ = true;<br>}<br>//----&lt destructor &gt---------------------------------------------------<br><br>FileInfo::~FileInfo()<br>{<br>  ::FindClose(hFindFile);<br>}<br>//----&lt is passed filespec valid? &gt------------------------------------<br><br>bool FileInfo::good()<br>{<br>  return good_;<br>}<br>//----&lt return file name &gt---------------------------------------------<br><br>std::string FileInfo::name() const<br>{<br>  return Path::getName(data.cFileName);<br>}<br>//----&lt conversion helper &gt--------------------------------------------<br><br>std::string FileInfo::intToString(long i)<br>{<br>  std::ostringstream out;<br>  out.fill('0');<br>  out &lt&lt std::setw(2) &lt&lt i;<br>  return out.str();<br>}<br>//----&lt return file date &gt---------------------------------------------<br><br>std::string FileInfo::date(dateFormat df) const<br>{<br>  std::string dateStr, timeStr;<br>  FILETIME ft;<br>  SYSTEMTIME st;<br>  ::FileTimeToLocalFileTime(&data.ftLastWriteTime, &ft);<br>  ::FileTimeToSystemTime(&ft, &st);<br>  dateStr = intToString(st.wMonth) + '/' + intToString(st.wDay) + '/' + intToString(st.wYear);<br>  timeStr = intToString(st.wHour) + ':' + intToString(st.wMinute) + ':' + intToString(st.wSecond);<br>  if(df == dateformat)<br>    return dateStr;<br>  if(df == timeformat)<br>    return timeStr;<br>  return dateStr + " " + timeStr;<br>}<br>//----&lt return file size &gt---------------------------------------------<br><br>size_t FileInfo::size() const<br>{<br>  return (size_t)(data.nFileSizeLow + (data.nFileSizeHigh &lt&lt 8));<br>}<br>//----&lt is type archive? &gt---------------------------------------------<br><br>bool FileInfo::isArchive() const<br>{<br>  return (data.dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE) != 0;<br>}<br>//----&lt is type compressed? &gt------------------------------------------<br><br>bool FileInfo::isCompressed() const<br>{<br>  return (data.dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) != 0;<br>}<br>//----&lt is type directory? &gt-------------------------------------------<br><br>bool FileInfo::isDirectory() const<br>{<br>  return (data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;<br>}<br>//----&lt is type encrypted? &gt---------------------------------------------<br><br>bool FileInfo::isEncrypted() const<br>{<br>  return (data.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) != 0;<br>}<br>//----&lt is type hiddent? &gt---------------------------------------------<br><br>bool FileInfo::isHidden() const<br>{<br>  return (data.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) != 0;<br>}<br>//----&lt is type normal? &gt---------------------------------------------<br><br>bool FileInfo::isNormal() const<br>{<br>  return (data.dwFileAttributes & FILE_ATTRIBUTE_NORMAL) != 0;<br>}<br>//----&lt is type offline? &gt---------------------------------------------<br><br>bool FileInfo::isOffLine() const<br>{<br>  return (data.dwFileAttributes & FILE_ATTRIBUTE_OFFLINE) != 0;<br>}<br>//----&lt is type readonly? &gt--------------------------------------------<br><br>bool FileInfo::isReadOnly() const<br>{<br>  return (data.dwFileAttributes & FILE_ATTRIBUTE_READONLY) != 0;<br>}<br>//----&lt is type system? &gt----------------------------------------------<br><br>bool FileInfo::isSystem() const<br>{<br>  return (data.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM  ) != 0;<br>}<br>//----&lt is type temporary? &gt-------------------------------------------<br><br>bool FileInfo::isTemporary() const<br>{<br>  return (data.dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY) != 0;<br>}<br>//----&lt compare names alphabetically &gt---------------------------------<br><br>bool FileInfo::operator&lt(const FileInfo& fi) const<br>{<br>  return strcmp(data.cFileName, fi.data.cFileName) == -1;<br>}<br>//----&lt compare names alphabetically &gt---------------------------------<br><br>bool FileInfo::operator==(const FileInfo& fi) const<br>{<br>  return strcmp(data.cFileName, fi.data.cFileName) == 0;<br>}<br>//----&lt compare names alphabetically &gt---------------------------------<br><br>bool FileInfo::operator&gt(const FileInfo& fi) const<br>{<br>  return strcmp(data.cFileName, fi.data.cFileName) == 1;<br>}<br>//----&lt compare file times &gt-------------------------------------------<br><br>bool FileInfo::earlier(const FileInfo& fi) const<br>{<br>  FILETIME ft1 = data.ftLastWriteTime;<br>  FILETIME ft2 = fi.data.ftLastWriteTime;<br>  return ::CompareFileTime(&ft1, &ft2) == -1;<br>}<br>//----&lt compare file times &gt-------------------------------------------<br><br>bool FileInfo::later(const FileInfo& fi) const<br>{<br>  FILETIME ft1 = data.ftLastWriteTime;<br>  FILETIME ft2 = fi.data.ftLastWriteTime;<br>  return ::CompareFileTime(&ft1, &ft2) == 1;<br>}<br>//----&lt smaller &gt------------------------------------------------------<br><br>bool FileInfo::smaller(const FileInfo &fi) const<br>{<br>  return size() &lt fi.size();<br>}<br>//----&lt larger &gt-------------------------------------------------------<br><br>bool FileInfo::larger(const FileInfo &fi) const<br>{<br>  return size() &gt fi.size();<br>}<br>//----&lt convert string to lower case chars &gt---------------------------<br><br>std::string Path::toLower(const std::string& src)<br>{<br>  std::string temp;<br>  for(size_t i=0; i&ltsrc.length(); ++i)<br>    temp += tolower(src[i]);<br>  return temp;<br>}<br>//----&lt convert string to upper case chars &gt---------------------------<br><br>  <br>std::string Path::toUpper(const std::string& src)<br>{<br>  std::string temp;<br>  for(size_t i=0; i&ltsrc.length(); ++i)<br>    temp += toupper(src[i]);<br>  return temp;<br>}<br>//----&lt get path from fileSpec &gt---------------------------------------<br><br>std::string Path::getName(const std::string &fileSpec, bool withExt)<br>{<br>  size_t pos = fileSpec.find_last_of("/");<br>  if(pos &gt= fileSpec.length())<br>  {<br>    pos = fileSpec.find_last_of("\\");<br>    if(pos &gt= fileSpec.length())<br>    {<br>      // no path prepended<br>      if(withExt)<br>        return fileSpec;<br>      else<br>      {<br>        // remove ext<br>        size_t pos = fileSpec.find(".");<br>        if(pos &gt fileSpec.size())<br>          return fileSpec;<br>        return fileSpec.substr(0, pos-1);<br>      }<br>    }<br>  }<br>  if(withExt)<br>    return fileSpec.substr(pos+1,fileSpec.length()-pos);<br>  else<br>  {<br>    // remove ext<br>    size_t pos2 = fileSpec.find(".", pos);<br>    if(pos2 &gt fileSpec.size())<br>      // no ext<br>      return fileSpec.substr(pos+1);<br>    return fileSpec.substr(pos+1, pos2-pos-1);<br>  }<br>}<br>//----&lt get extension from fileSpec &gt----------------------------------<br>  <br>std::string Path::getExt(const std::string& fileSpec)<br>{<br>  size_t pos1 = fileSpec.find_last_of('/');<br>  size_t pos2 = fileSpec.find_last_of('\\');<br>  size_t pos = fileSpec.find_last_of('.');<br>  // handle ../ or ..\\ with no extension<br>  if(pos1 &lt fileSpec.length() || pos2 &lt fileSpec.length())<br>  {<br>    if(pos &lt min(pos1, pos2))<br>      return std::string("");<br>  }<br>  // only . is extension delimiter<br>  if(0 &lt= pos && pos &lt fileSpec.length())<br>    return toLower(fileSpec.substr(pos+1,fileSpec.length()-pos));<br>  return std::string("");<br>}<br>//----&lt get path from fileSpec &gt---------------------------------------<br><br>std::string Path::getPath(const std::string &fileSpec)<br>{<br>  size_t pos = fileSpec.find_last_of("/");<br>  if(pos &gt= fileSpec.length())<br>    pos = fileSpec.find_last_of("\\");<br>  if(pos &gt= fileSpec.length())<br>    return ".";<br>  if(fileSpec.find(".",pos+1))<br>    return fileSpec.substr(0,pos+1);<br>  return fileSpec;<br>}<br>//----&lt get absoluth path from fileSpec &gt------------------------------<br><br>std::string Path::getFullFileSpec(const std::string &fileSpec)<br>{<br>  const size_t BufSize = 256;<br>  char buffer[BufSize];<br>  char filebuffer[BufSize];  // don't use but GetFullPathName will<br>  char* name = filebuffer;<br>  ::GetFullPathNameA(fileSpec.c_str(),BufSize, buffer, &name);<br>  return std::string(buffer);<br>}<br>//----&lt create file spec from path and name &gt--------------------------<br><br>std::string Path::fileSpec(const std::string &path, const std::string &name)<br>{<br>  std::string fs;<br>  size_t len = path.size();<br>  if(path[len-1] == '/' || path[len-1] == '\\')<br>    fs = path + name;<br>  else<br>  {<br>    if(path.find("/") &lt path.size())<br>      fs = path + "/" + name;<br>    else if(path.find("\\") &lt path.size())<br>      fs = path + "\\" + name;<br>    else<br>      fs = path + "/" + name;<br>  }<br>  return fs;<br>}<br>//----&lt return name of the current directory &gt-----------------------------<br><br>std::string Directory::getCurrentDirectory()<br>{<br>  char buffer[MAX_PATH];<br>  ::GetCurrentDirectoryA(MAX_PATH,buffer);<br>  return std::string(buffer);<br>}<br>//----&lt change the current directory to path &gt-----------------------------<br><br>bool Directory::setCurrentDirectory(const std::string& path)<br>{<br>  return ::SetCurrentDirectoryA(path.c_str()) != 0;<br>}<br>//----&lt get names of all the files matching pattern (path:name) &gt----------<br><br>std::vector&ltstd::string&gt Directory::getFiles(const std::string& path, const std::string& pattern)<br>{<br>  std::vector&ltstd::string&gt files;<br>  FileSystemSearch fss;<br>  std::string file = fss.firstFile(path, pattern);<br>  if(file.size() == 0)<br>    return files;<br>  files.push_back(file);<br>  while(true)<br>  {<br>    file = fss.nextFile();<br>    if(file.size() == 0)<br>      return files;<br>    files.push_back(file);<br>  }<br>  return files;<br>}<br>//----&lt get names of all directories matching pattern (path:name) &gt--------<br><br>std::vector&ltstd::string&gt Directory::getDirectories(const std::string& path, const std::string& pattern)<br>{<br>  std::vector&ltstd::string&gt dirs;<br>  FileSystemSearch fss;<br>  std::string dir = fss.firstDirectory(path, pattern);<br>  if(dir.size() == 0)<br>    return dirs;<br>  dirs.push_back(dir);<br>  while(true)<br>  {<br>    dir = fss.nextDirectory();<br>    if(dir.size() == 0)<br>      return dirs;<br>    dirs.push_back(dir);<br>  }<br>  return dirs;<br>}<br>//----&lt create directory &gt-------------------------------------------------<br><br>bool Directory::create(const std::string& path)<br>{<br>  return ::CreateDirectoryA(path.c_str(), NULL) == 0;<br>}<br>//----&lt does directory exist? &gt--------------------------------------------<br><br>bool Directory::exists(const std::string& path)<br>{<br>  DWORD dwAttrib = GetFileAttributesA(path.c_str());<br><br>  return (dwAttrib != INVALID_FILE_ATTRIBUTES && <br>         (dwAttrib & FILE_ATTRIBUTE_DIRECTORY));<br>}<br>//----&lt remove directory &gt-------------------------------------------------<br><br>bool Directory::remove(const std::string& path)<br>{<br>  return ::RemoveDirectoryA(path.c_str()) == 0;<br>}<br>//----&lt find first file &gt--------------------------------------------------<br><br>std::string FileSystemSearch::firstFile(const std::string& path, const std::string& pattern)<br>{<br>  hFindFile = ::FindFirstFileA(Path::fileSpec(path, pattern).c_str(), pFindFileData);<br>  if(hFindFile != INVALID_HANDLE_VALUE)<br>  {<br>    if(!(pFindFileData-&gtdwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))<br>      return pFindFileData-&gtcFileName;<br>    else<br>      while(::FindNextFileA(hFindFile, pFindFileData))<br>        if(!(pFindFileData-&gtdwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))<br>          return pFindFileData-&gtcFileName;<br>  }<br>  return "";<br>}<br>//----&lt find next file &gt---------------------------------------------------<br><br>std::string FileSystemSearch::nextFile()<br>{<br>  while(::FindNextFileA(hFindFile, pFindFileData))<br>    if(!(pFindFileData-&gtdwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))<br>      return pFindFileData-&gtcFileName;<br>  return "";<br>}<br>//----&lt find first file &gt--------------------------------------------------<br><br>std::string FileSystemSearch::firstDirectory(const std::string& path, const std::string& pattern)<br>{<br>  hFindFile = ::FindFirstFileA(Path::fileSpec(path, pattern).c_str(), pFindFileData);<br>  if(hFindFile != INVALID_HANDLE_VALUE)<br>  {<br>    if(pFindFileData-&gtdwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)<br>      return pFindFileData-&gtcFileName;<br>    else<br>      while(::FindNextFileA(hFindFile, pFindFileData))<br>        if(pFindFileData-&gtdwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)<br>          return pFindFileData-&gtcFileName;<br>  }<br>  return "";<br>}<br>//----&lt find next file &gt---------------------------------------------------<br><br>std::string FileSystemSearch::nextDirectory()<br>{<br>  while(::FindNextFileA(hFindFile, pFindFileData))<br>    if(pFindFileData-&gtdwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)<br>      return pFindFileData-&gtcFileName;<br>  return "";<br>}<br>//----&lt test stub &gt--------------------------------------------------------<br><br>#ifdef TEST_FILESYSTEM<br><br>void title(const std::string& title, char ch='=')<br>{<br>  std::cout &lt&lt "\n  " &lt&lt title;<br>  std::cout &lt&lt "\n " &lt&lt std::string(title.size()+2, ch);<br>}<br>int main(int argc, char* argv[])<br>{<br>  title("Demonstrate Path Class");<br><br>  std::string fs = Path::fileSpec(".","temp.txt");<br>  std::cout &lt&lt "\n  Path::fileSpec(\".\",\"temp.txt\") = " &lt&lt fs;<br><br>  std::string path = Path::getPath(fs);<br>  std::cout &lt&lt "\n  Path::getPath(\"" + fs + "\") = " &lt&lt path;<br>  <br>  std::string ffs = Path::getFullFileSpec(fs);<br>  std::cout &lt&lt "\n  Path::getFullFileSpec(\"" + fs + "\") = " &lt&lt ffs;<br>  <br>  std::string name = Path::getName(fs);<br>  std::cout &lt&lt "\n  Path::getName(\"" + fs + "\") = " &lt&lt name;<br><br>  std::string ext = Path::getExt(fs);<br>  std::cout &lt&lt "\n  Path::getExt(\"" + fs + "\") = " &lt&lt ext;<br><br>  std::string upper = Path::toUpper("temp.txt");<br>  std::cout &lt&lt "\n  Path::toUpper(\"temp.txt\") = " &lt&lt upper;<br><br>  std::string lower = Path::toLower("Temp.Txt");<br>  std::cout &lt&lt "\n  Path::toLower(\"Temp.Txt\") = " &lt&lt lower;<br>  std::cout &lt&lt std::endl;<br><br>  title("Demonstrate Directory class");<br><br>  // Display contents of current directory<br><br>  std::cout &lt&lt "\n  current directory is:\n    " &lt&lt Directory::getCurrentDirectory();<br>  std::cout &lt&lt "\n  It contains files:";<br>  std::vector&ltstd::string&gt currfiles = Directory::getFiles();<br>  ///////////////////////////////////////////////////////<br>  // This works too<br>  // std::vector&ltstd::string&gt currfiles = d.getFiles();  <br>  for(size_t i=0; i&ltcurrfiles.size(); ++i)<br>    std::cout &lt&lt "\n    " &lt&lt currfiles[i].c_str();<br>  std::cout &lt&lt "\n  and contains directories:";<br>  std::vector&ltstd::string&gt currdirs = Directory::getDirectories();<br>  for(size_t i=0; i&ltcurrdirs.size(); ++i)<br>    std::cout &lt&lt "\n    " &lt&lt currdirs[i].c_str();<br>  std::cout &lt&lt "\n";<br><br>  // Display contents of non-current directory<br><br>  std::cout &lt&lt "\n  .txt files residing in C:/temp are:";<br>  currfiles = Directory::getFiles("c:/temp/", "*.txt");<br><br>  // if we want fully qualified file names, we have to<br>  // set the current directory to the path on which the files<br>  // reside, if it isn't already so set<br><br>  std::string currDir = Directory::getCurrentDirectory();<br>  Directory::setCurrentDirectory("c:/temp/");<br>  for(size_t i=0; i&ltcurrfiles.size(); ++i)<br>    std::cout &lt&lt "\n    " &lt&lt Path::getFullFileSpec(currfiles[i]).c_str();<br>  Directory::setCurrentDirectory(currDir);<br><br>  // we have to restore the current directory so the<br>  // remaining tests work<br><br>  // it's probably easier just to use Path::fileSpec(path, filename)<br>  // like this:<br><br>  for (size_t i = 0; i&ltcurrfiles.size(); ++i)<br>    std::cout &lt&lt "\n    " &lt&lt Path::fileSpec("c:\\temp\\", currfiles[i]).c_str();<br><br>  std::cout &lt&lt "\n";<br>  std::cout &lt&lt "\n  directories residing in C:/temp are:";<br>  currdirs = Directory::getDirectories("c:/temp/");<br>  for(size_t i=0; i&ltcurrdirs.size(); ++i)<br>    std::cout &lt&lt "\n    " &lt&lt currdirs[i].c_str();<br>  std::cout &lt&lt "\n";<br><br>  // Create directory<br><br>  title("Demonstrate FileInfo Class Operations", '=');<br>  std::cout &lt&lt "\n";<br><br>  Directory::setCurrentDirectory(".");<br>  std::cout &lt&lt "\n  current path is \"" &lt&lt Directory::getCurrentDirectory();<br>  <br>  std::string fn1;<br>  if(argc &gt 1)<br>    fn1 = argv[1];<br>  else<br>    fn1 = "c:\\temp\\test.txt";<br>  FileInfo fi(fn1);<br><br>  if(fi.good())<br>  {<br>    std::cout &lt&lt "\n  name: " &lt&lt "\t" &lt&lt fi.name();<br>    std::cout &lt&lt "\n  date: " &lt&lt "\t" &lt&lt fi.date();<br>    std::cout &lt&lt "\n  date: " &lt&lt "\t" &lt&lt fi.date(FileInfo::dateformat);<br>    std::cout &lt&lt "\n  date: " &lt&lt "\t" &lt&lt fi.date(FileInfo::timeformat);<br>    std::cout &lt&lt "\n  size: " &lt&lt "\t" &lt&lt fi.size() &lt&lt " bytes";<br>    if(fi.isArchive())<br>      std::cout &lt&lt "\n  is archive";<br>    else<br>      std::cout &lt&lt "\n  is not archive";<br>    if(fi.isCompressed())<br>      std::cout &lt&lt "\n  is compressed";<br>    else<br>      std::cout &lt&lt "\n  is not compressed";<br>    if(fi.isDirectory())<br>      std::cout &lt&lt "\n  is directory";<br>    else<br>      std::cout &lt&lt "\n  is not directory";<br>    if(fi.isEncrypted())<br>      std::cout &lt&lt "\n  is encrypted";<br>    else<br>      std::cout &lt&lt "\n  is not encrypted";<br>    if(fi.isHidden())<br>      std::cout &lt&lt "\n  is hidden";<br>    else<br>      std::cout &lt&lt "\n  is not hidden";<br>    if(fi.isNormal())<br>      std::cout &lt&lt "\n  is normal";<br>    else<br>      std::cout &lt&lt "\n  is not normal";<br>    if(fi.isOffLine())<br>      std::cout &lt&lt "\n  is offline";<br>    else<br>      std::cout &lt&lt "\n  is not offline";<br>    if(fi.isReadOnly())<br>      std::cout &lt&lt "\n  is readonly";<br>    else<br>      std::cout &lt&lt "\n  is not readonly";<br>    if(fi.isSystem())<br>      std::cout &lt&lt "\n  is system";<br>    else<br>      std::cout &lt&lt "\n  is not system";<br>    if(fi.isTemporary())<br>      std::cout &lt&lt "\n  is temporary";<br>    else<br>      std::cout &lt&lt "\n  is not temporary";<br>  }<br>  else<br>    std::cout &lt&lt "\n  filename " &lt&lt fn1 &lt&lt " is not valid in this context\n";<br><br>  std::string fn2;<br>  if(argc &gt 2)<br>  {<br>    fn1 = argv[1];<br>    fn2 = argv[2];<br>  }<br>  else<br>  {<br>    fn1 = "FileSystem.h";<br>    fn2 = "FileSystem.cpp";<br>  }<br>  FileInfo fi1(fn1);<br>  FileInfo fi2(fn2);<br>  if(fi1.good() && fi2.good())<br>  {<br>    if(fi1 == fi1)<br>      std::cout &lt&lt "\n  " &lt&lt fi1.name() &lt&lt " == " &lt&lt fi1.name();<br>    else<br>      std::cout &lt&lt "\n  " &lt&lt fi1.name() &lt&lt " != " &lt&lt fi1.name();<br>    if(fi1 &lt fi1)<br>      std::cout &lt&lt "\n  " &lt&lt fi1.name() &lt&lt " &lt " &lt&lt fi1.name();<br>    else<br>      std::cout &lt&lt "\n  " &lt&lt fi1.name() &lt&lt " &gt= " &lt&lt fi1.name();<br>    if(fi1 == fi2)<br>      std::cout &lt&lt "\n  " &lt&lt fi1.name() &lt&lt " == " &lt&lt fi2.name();<br>    else<br>      std::cout &lt&lt "\n  " &lt&lt fi1.name() &lt&lt " != " &lt&lt fi2.name();<br>    if(fi1 &lt fi2)<br>      std::cout &lt&lt "\n  " &lt&lt fi1.name() &lt&lt " &lt " &lt&lt fi2.name();<br>    else<br>      std::cout &lt&lt "\n  " &lt&lt fi1.name() &lt&lt " &gt= " &lt&lt fi2.name();<br>    if(fi1.smaller(fi2))<br>      std::cout &lt&lt "\n  " &lt&lt fi1.name() &lt&lt " is smaller than " &lt&lt fi2.name();<br>    else<br>      std::cout &lt&lt "\n  " &lt&lt fi1.name() &lt&lt " is not smaller than " &lt&lt fi2.name();<br>    if(fi1.earlier(fi2))<br>      std::cout &lt&lt "\n  " &lt&lt fi1.name() &lt&lt " is earlier than " &lt&lt fi2.name();<br>    else<br>      std::cout &lt&lt "\n  " &lt&lt fi1.name() &lt&lt " is not earlier than " &lt&lt fi2.name();<br>    std::cout &lt&lt std::endl;<br>  }<br>  else<br>    std::cout &lt&lt "\n  files " &lt&lt fn1 &lt&lt " and " &lt&lt fn2 &lt&lt " are not valid in this context\n";<br><br>  title("Demonstrate File class operations", '=');<br>  std::cout &lt&lt "\n";<br><br>  // copy binary file from one directory to another<br><br>  File me("../debug/filesystemdemo.exe");<br>  me.open(File::in, File::binary);<br>  std::cout &lt&lt "\n  copying " &lt&lt me.name().c_str() &lt&lt " to c:/temp";<br>  if(!me.isGood())<br>  {<br>    std::cout &lt&lt "\n  can't open executable\n";<br>    std::cout &lt&lt "\n  looking for:\n  ";<br>    std::cout &lt&lt Path::getFullFileSpec(me.name()) &lt&lt "\n";<br>  }<br>  else<br>  {<br>    File you("c:/temp/fileSystemdemo.exe");<br>    you.open(File::out, File::binary);<br>    if(you.isGood())<br>    {<br>      while(me.isGood())<br>      {<br>        static size_t count = 0;<br>        Block b = me.getBlock(1024);<br>        you.putBlock(b);<br>        if (++count &lt 10)<br>        {<br>          std::cout &lt&lt "\n    reading block of " &lt&lt b.size() &lt&lt " bytes";<br>          std::cout &lt&lt "\n    writing block of " &lt&lt b.size() &lt&lt " bytes";<br>        }<br>        if (b.size() &lt 1024)<br>        {<br>          std::cout &lt&lt "\n\n    omitted " &lt&lt count-10 &lt&lt " blocks from display\n\n";<br>          std::cout &lt&lt "\n    reading block of " &lt&lt b.size() &lt&lt " bytes";<br>          std::cout &lt&lt "\n    writing block of " &lt&lt b.size() &lt&lt " bytes";<br>        }<br>      }<br>      std::cout &lt&lt "\n";<br>    }<br>  }<br><br>  // save some filespecs of text files in a vector for File demonstrations<br><br>  std::vector&ltstd::string&gt files;<br>  if(argc == 1)<br>  {<br>    std::cout &lt&lt "\n\n  Enter, on the command line, an additional filename to process.\n";<br>  }<br><br>  for(int i=1; i&ltargc; ++i)<br>  {<br>    files.push_back(argv[i]);<br>  }<br>  files.push_back("FileSystem.cpp");                     // file not on current path<br>  files.push_back("../FileSystemDemo/FileSystem.cpp");   // file from project directory<br>  files.push_back("../FileSystemTest.txt");              // file in solution directory<br>  files.push_back("foobar");                             // doesn't exist<br><br>  // open each file and display a few lines of text<br><br>  for(size_t i=0; i&ltfiles.size(); ++i)<br>  {<br>    File file(files[i]);<br>    file.open(File::in);<br>    if(!file.isGood())<br>    {<br>      std::cout &lt&lt "\n  Can't open file " &lt&lt file.name();<br>      std::cout &lt&lt "\n  Here's what the program can't find:\n  " &lt&lt Path::getFullFileSpec(file.name()); <br>      continue;<br>    }<br>    std::string temp = std::string("Processing file ") + files[i];<br>    title(temp, '-');<br>    for(int j=0; j&lt10; ++j)<br>    {<br>      if(!file.isGood())<br>        break;<br>      std::cout &lt&lt "\n  -- " &lt&lt file.getLine().c_str();<br>    }<br>    std::cout &lt&lt "\n";<br>  }<br>  std::cout &lt&lt "\n";<br><br>  // read all lines of text file into string<br><br>  title("testing File::readAll()", '-');<br>  std::cout &lt&lt "\n";<br>  File testAll("../FileSystemTest.txt");<br>  testAll.open(File::in);<br>  if (testAll.isGood())<br>  {<br>    std::string all = testAll.readAll();<br>    std::cout &lt&lt all &lt&lt "\n";<br>  }<br>  testAll.close();<br><br>  title("testing File::readAll(true)", '-');<br>  std::cout &lt&lt "\n";<br>  File testAllTrue("../FileSystemTest.txt");<br>  testAllTrue.open(File::in);<br>  if (testAllTrue.isGood())<br>  {<br>    std::string all = testAllTrue.readAll(true);<br>    std::cout &lt&lt all &lt&lt "\n";<br>  }<br>  testAllTrue.close();<br><br>  // test reading non-text files<br><br>  title("test reading non-text files", '-');<br>  std::cout &lt&lt "\n  Attempting to open Visual Studio files.";<br>  std::cout &lt&lt "\n  These are locked by VS when running from IDE.";<br>  std::cout &lt&lt "\n  They will open if you run FileSystemDemo from the debug folder,";<br>  std::cout &lt&lt "\n  provided you've closed the solution in VS.\n";<br>  std::cout &lt&lt "\n";<br>  std::string testPath = "./debug";  // run from project directory (what Visual Studio does)<br>  if (!Directory::exists(testPath))<br>    testPath = ".";                  // run from solution debug directory<br>  std::vector&ltstd::string&gt testFiles = Directory::getFiles(testPath);<br>  for (auto file : testFiles)<br>  {<br>    try<br>    {<br>      std::string ext = Path::getExt(file);<br>      if (ext == "exe" || ext == "obj" || ext == "dll" || file == "run.dat")<br>      {<br>        /* reading binary file works, but generates a lot of garbage */<br>        /* I use run.dat to capture this output so including will make output confusing */<br><br>        std::cout &lt&lt "  skipping binary file " &lt&lt file &lt&lt "\n";<br>        continue;<br>      }<br>      File test(file);<br>      test.open(File::in);  // open as text file<br>      std::cout &lt&lt "\n  processing \"" &lt&lt file &lt&lt "\"\n";<br>      if (test.isGood())<br>      {<br>        std::string text = test.readAll(true);<br>        std::cout &lt&lt text &lt&lt "\n";<br>      }<br>      else<br>      {<br>        std::cout &lt&lt "\n  open failed\n";<br>      }<br>    }<br>    catch (std::exception& ex)<br>    {<br>      std::cout &lt&lt "\n  Exception: " &lt&lt ex.what() &lt&lt "\n";<br>    }<br>  }<br><br>  // read text file and write to another text file<br><br>  title("writing to c:/temp/test.txt", '-');<br>  File in("../FileSystemDemo/FileSystem.h");<br>  in.open(File::in, File::text);<br>  File out("c:/temp/test.txt");<br>  out.open(File::out, File::text);<br>  while(in.isGood() && out.isGood())<br>  {<br>    std::string temp = in.getLine();<br>    //std::cout &lt&lt "\n  " &lt&lt temp.c_str();<br>    out.putLine(temp);<br>    out.putLine("\n");<br>  }<br>  std::cout &lt&lt "\n  check c:/temp/test.txt to validate";<br>  std::cout &lt&lt "\n\n";<br><br>  // read and write buffers<br><br>  title("reading and writing buffers");<br>  std::cout &lt&lt "\n  " &lt&lt FileSystem::Directory::getCurrentDirectory();<br>  std::string fileIn = "../TestFileSystem/UnitTest.h";<br>  std::string fileOut = "../TestFileSystem/CopyOfUnitTest.h";<br>  File bufferIn(fileIn);<br>  bufferIn.open(File::in, File::binary);<br>  if (!bufferIn.isGood())<br>  {<br>    std::cout &lt&lt "\n  could not open \"" &lt&lt fileIn &lt&lt "\" for reading";<br>      return 1;<br>  }<br>  else<br>  {<br>    std::cout &lt&lt "\n  opening: \"" &lt&lt fileIn &lt&lt "\" for reading";<br>  }<br>  File bufferOut(fileOut);<br>  bufferOut.open(File::out, File::binary);<br>  if (!bufferOut.isGood())<br>  {<br>    std::cout &lt&lt "\n  could not open \"" &lt&lt fileOut &lt&lt "\" for writing\n\n";<br>      return 1;<br>  }<br>  else<br>  {<br>    std::cout &lt&lt "\n  opening: \"" &lt&lt fileOut &lt&lt "\" for writing";<br>  }<br>  std::cout &lt&lt "\n";<br>  const size_t bufLen = 124;<br>  File::byte buffer[bufLen];<br>  while (true)<br>  {<br>    size_t resultSize = bufferIn.getBuffer(bufLen, buffer);<br>    //std::cout &lt&lt "\n  reading buffer of size " &lt&lt resultSize &lt&lt " bytes";<br>    std::string temp1(buffer, resultSize);<br>    std::cout &lt&lt temp1;<br>    //std::cout &lt&lt "\n  writing buffer of size " &lt&lt resultSize &lt&lt "bytes";<br>    bufferOut.putBuffer(resultSize, buffer);<br>    if (resultSize &lt bufLen || !bufferIn.isGood() || !bufferOut.isGood())<br>    {<br>      bufferIn.close();<br>      bufferOut.close();<br>      break;<br>    }<br>  }<br>  std::cout &lt&lt "\n\n";<br>}<br>#endif</pre>  </body>
</html>